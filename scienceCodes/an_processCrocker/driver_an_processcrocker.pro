;v1.38 A bug corrected in pxx and pyy calculation 
;v1.34 with calculation of pxx and pxy. Now working and printing 
PRO driver_an_processCrocker
;define borders of the region of interest
leftBorder = 550.0d
rightBorder= 850.0d;
yMin = 222.0d;
yMax = 1050.0d
framestep = 8 ;number of frames to skip
frameRate = 800;
awzPixel = 7.191d ;Wigner-Zeiss radius in pixels
kappaPixel = awzpixel / SQRT(2.0d * !DPI / SQRT(3.0d))
scale = 1.0d / awzpixel ;scale in Wigner-Zeiss radii
bWidth = 5.0d * awzpixel ; border width along the region of interest.
;It Used in calculating pressure pxx and pyy
scaleMeters = (1.0d / 29.790d) / 1000.0d
lambda = scaleMeters * awzPixel / kappaPixel ; screening length
m = DOUBLE(5.188e-13); kg
kB = DOUBLE(1.38e-23);J/K
Q = DOUBLE(14974.3d * 1.60217E-19) ;charge
clight = DOUBLE(2.9979E8) ;light speed
eps0 = DOUBLE(1.0E7/4.0d/!DPI/clight^2) ; dielectric permittivity
;  of vacuum
kconst = 1.0d / 4.0d / !DPI / eps0 ; coefficient of proportionality
;  in the Coulomb law
kQ2 = kconst * Q^2; define this constant so that we don't
;  recalculate it in the cycles
potEnergy = kQ2/(awzPixel*scaleMeters)
potEnergyInDegrees = potEnergy / kB
;stop


dt = DOUBLE(framestep) / DOUBLE(framerate)
dY = (1/scale)*2.0d
nB = FLOOR((yMax - yMin)/dY)
iEquillibr = 767
iBegin=874
yBins = DINDGEN(nB)*dY+yMin + dY/2

;variable to store array dimension value:
arrlen = 0
ncols = 3 ;number of columns in the array which stores all the data  
distInMM = yBins*scale; x coordinate in physical units

;input the data generated by the imageJ
s = readImageJK(/lowmem);
;stop
iBegin = MIN(s.iFrame)
mFrame = MAX(s.iFrame)
;we need only the data inside the region of interest
ind = WHERE(s.X LE rightBorder AND s.X GE leftBorder $
              AND s.Y LE ymax AND s.Y GE yMin)               
arrlen = N_ELEMENTS(s.X[ind]);              
;we also need the particles, which fit in the region of 
;interest PLUS fat border width. We shall need them later,
;when we shall be calculating the potential part of 
; pxx and pyy:
indWithBorder = WHERE(s.X LE rightBorder + bWidth $
  AND s.X GE leftBorder - bWidth $
  AND s.Y LE ymax + bWidth AND s.Y GE yMin - bWidth)
  


;prepare the input array to use with the Crokcer's track() function:

trackArr = DBLARR(ncols,arrlen)
xywithborderArr = DBLARR(3,N_ELEMENTS(indWithBorder)); supplementary array
; with excessive particles on the borders for calsulation
; of the potential part of pxx and pyy
trackArr[0,0] = TRANSPOSE(s.X[ind])
xywithborderArr[0,0] = TRANSPOSE(s.X[indWithBorder])
trackArr[1,0] = TRANSPOSE(yMax - s.Y[ind]) ;because the vertical screen coordinates
  ;are from top to bottom, we make this change of variables
xywithborderArr[1,0] = TRANSPOSE(yMax - s.Y[indWithBorder])
trackArr[2,0] = TRANSPOSE(s.iFrame[ind])
xywithborderArr[2,0] = TRANSPOSE(s.iFrame[indWithBorder])
s = 0; ;save the memory:

; 2 frames threading using Crocker's code:
;stop
FOR i=iBegin, mFrame -framestep-2 DO BEGIN
; in order to implement 2 frames threading cut out only two frames:
indf = WHERE(trackArr[2,*] EQ i+framestep OR trackArr[2,*] EQ i)
;stop
curArr = trackArr[*,indf]
res = track(curArr,4.0d)

ilen = N_ELEMENTS(res[3,*])
ncols = 8
fuli = DBLARR(ncols,ilen)

fuli[0,0] = res[0,*]
fuli[1,0] = res[1,*]
fuli[4,0] = res[2,*]
fuli[5,0] = res[3,*]
  for k = 0L, ilen-1 do begin
    if (k + framestep LT ilen) then begin
    ;calculating velocities of the particles:
      if (fuli[5,k] eq fuli[5,k+1]) then begin
        fuli[2,k+1] = fuli[0,k+1] - fuli[0,k]; vx
        fuli[3,k+1] = fuli[1,k+1] - fuli[1,k]; vy
        ;calculate data for pxx and pxy
      	;distances to the  closest neighbours:
      	;(notice, that we are calculating the index of the
      	;array indwithborderArr):
      	xk = fuli[0,k]
      	yk = fuli[1,k]
      	indNeighb = WHERE(xywithborderArr[2,*] EQ i $
        	AND (xk - xywithborderArr[0,*])^2 + (yk - xywithborderArr[1,*])^2  LE bWidth^2 $
        	AND  (xk - xywithborderArr[0,*])^2 + (yk - xywithborderArr[1,*])^2 GT 0.0d )
        xDisArr = xywithborderArr[0,indNeighb] - xk
      yDisArr = xywithborderArr[1,indNeighb] - yk
      RDisArr = sqrt((xDisArr)^2+(yDisArr)^2)
      fuli[6,k+1] = m*(scaleMeters * fuli[2,k+1])^2 +  TOTAL(-kQ2/2.0d*RdisArr*(1.0d/lambda+1.0d/RdisArr)*exp(-RdisArr/Lambda)*xDisArr^2/RDisArr)
      fuli[7,k+1] = m*(scaleMeters * fuli[3,k+1])^2 +  TOTAL(-kQ2/2.0d*RdisArr*(1.0d/lambda+1.0d/RdisArr)*exp(-RdisArr/Lambda)*yDisArr^2/RDisArr)
      endif
    endif    
  endfor
 
fuli = fuli[*,WHERE(fuli[4,*] EQ i+framestep)]

;building histogram using cloud-in-cell (cic):
YforHist = TRANSPOSE(fuli[1,*])/yMax*nB
weighNumDens = DBLARR(N_ELEMENTS(YforHist))+1 ; weights for the number density
fieldKEnergy = (fuli[2,*])^2 + (fuli[3,*])^2

fieldVx = scaleMeters * (fuli[2,*] / dt) 
fieldVy = scaleMeters * (fuli[3,*] / dt)
fieldVx2 = fieldVx^2
fieldVy2 = fieldVy^2
fieldPxx = fuli[6,*]
fieldPyy = fuli[7,*]
 
histVx = CIC(fieldVx, YforHist, nB, /ISOLATED, /AVERAGE)
histVy = CIC(fieldVy, YforHist, nB, /ISOLATED, /AVERAGE)
histVx2 = CIC(fieldVx2, YforHist, nB, /ISOLATED, /AVERAGE)
histVy2 =  CIC(fieldVy2, YforHist, nB, /ISOLATED, /AVERAGE)
histTemperX = m * (histVx2 - (histVx)^2) / 2.0d / kB
histTemperY = m * (histVy2 - (histVy)^2) / 2.0d / kB
histPxx =  CIC(fieldPxx, YforHist, nB, /ISOLATED)
histPyy =  CIC(fieldPyy, YforHist, nB, /ISOLATED)
histNumDens = CIC(weighNumDens, YforHist, nB, /ISOLATED)
histKinEnergy = m* (histVx2 + histVy2) / 2.0d

;p =plot(distInMM,histTemperX, OVERPLOT = 1, XRANGE = [0,120], Color = 'red')
;p =plot(distInMM,histVx, OVERPLOT = 1, XRANGE = [0,120], Color = 'blue')
;p =plot(distInMM,  potEnergyInDegrees / histTemperY, OVERPLOT = 1, XRANGE = [30,120])
;p =plot(distInMM,histPxx, OVERPLOT = 1, XRANGE = [30,120])

p =plot(distInMM,histNumDens, OVERPLOT = 1, XRANGE = [0,120])

print, 'frame = ',i
print, 'tan(alpha) = ', MEAN(histVx) / MEAN(histVy) 
filename = STRCOMPRESS('histo_frame'+STRING(i,FORMAT='(I04)')+'.csv')
z=print8arrays(filename,distInMM,histNumDens,histTemperX,histTemperY,histKinEnergy,histVy,histPxx,histPyy)  
;  if (i eq 874) then begin
;    stop
;  endif


;stop

ENDFOR


END